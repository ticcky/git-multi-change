#!/bin/bash
# Takes a snapshot of the current working tree into `snapshots` branch.
#
# Configuration in VSCode to auto-run this every N minutes:
# 1. Put the below script to: ~/Library/Application Support/Code/User/tasks.json
# 2. In VSCode: "Tasks: Manage automatic tasks" -> "Allow automatic tasks"
#
#
# {
#   "version": "2.0.0",
#   "tasks": [
#     {
#       "label": "Snapshot working tree every 10 seconds",
#       "type": "shell",
#       "command": "bash",
#       "args": [
#         "-lc",
#         // loop forever; run script; sleep; repeat
#         "while true; do git msnap; sleep 10; done"
#       ],
#       "options": {
#         "cwd": "${workspaceFolder}"
#       },
#       "isBackground": true,
#       "problemMatcher": [],
#       "runOptions": {
#         "runOn": "folderOpen"       // auto-start when you open this repo
#       },
#       "presentation": {
#         "reveal": "never",
#         "panel": "dedicated",
#         "clear": false
#       }
#     }
#   ]
# }

set -euo pipefail

if [[ ! -e .git ]]; then
    echo "No git repo found here."
    exit 1
fi

if [[ "$#" == "1" ]]; then
  custom_log_msg="$1"
else
  custom_log_msg=""
fi


branch="snapshots"                # where snapshots live
snap_ref="refs/heads/$branch"

# Current HEAD (may be empty in a new repo)
head_oid="$(git rev-parse -q HEAD 2>/dev/null || true)"
# Current snapshot tip (if any)
snap_tip="$(git rev-parse -q --verify "$snap_ref" 2>/dev/null || true)"

tmp_index="$(mktemp)"; export GIT_INDEX_FILE="$tmp_index"
cleanup() { rm -f "$tmp_index"; unset GIT_INDEX_FILE; }
trap cleanup EXIT

# 1) Seed TEMP index so unchanged tracked files are included
[ -n "$head_oid" ] && git read-tree "$head_oid" || :

# 2) Stage the *working directory* into the TEMP index:
#    - tracked mods + deletions
#    - untracked files
#    - EXCLUDING ignored per .gitignore (e.g., .venv/)
git add -A

# 3) This tree represents the *current working directory snapshot*
new_tree="$(git write-tree)"

# 4) Compare against the *last snapshot’s tree* (not HEAD)
if [[ -n "$snap_tip" && "$custom_log_msg" == "" ]]; then
  last_tree="$(git rev-parse "$snap_tip^{tree}")"
  if [ "$new_tree" = "$last_tree" ]; then
    echo "No changes since last snapshot ($branch); skipping."
    exit 0
  fi
fi

# 5) Create a commit:
#    - First parent: previous snapshot (keeps a linear snapshot timeline)
#    - Second parent (optional): current HEAD, for context
parents=()
[ -n "$snap_tip" ] && parents+=(-p "$snap_tip")
[ -n "$head_oid" ] && parents+=(-p "$head_oid")

msg="snapshot: $(date -Iseconds)"
if [[ "$custom_log_msg" != "" ]]; then
  msg="$custom_log_msg $msg"
fi
commit_oid="$(printf "%s\n" "$msg" | git commit-tree "$new_tree" "${parents[@]}")"

# 6) Advance (or create) the snapshots ref atomically
if [ -n "$snap_tip" ]; then
  git update-ref "$snap_ref" "$commit_oid" "$snap_tip"
else
  git update-ref "$snap_ref" "$commit_oid"
fi

echo "Snapshot saved → $branch: $(git rev-parse --short "$commit_oid")"
